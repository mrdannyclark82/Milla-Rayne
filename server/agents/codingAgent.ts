import { BaseAgent } from './base';
import { AgentTask } from './taskStorage';
import {
  createSandbox,
  addFeatureToSandbox,
  testFeature,
  evaluateSandboxReadiness,
  markSandboxForMerge,
  type SandboxEnvironment,
  type SandboxFeature,
} from '../sandboxEnvironmentService';
import { createPRForSandbox } from '../automatedPRService';
import {
  analyzeCodeForIssues,
  type SecurityIssue,
  type PerformanceIssue,
  type CodeQualityIssue,
} from '../codeAnalysisService';

export interface IssueIdentification {
  issueType: 'bug' | 'enhancement' | 'security' | 'performance';
  description: string;
  affectedFiles: string[];
  severity: 'low' | 'medium' | 'high' | 'critical';
}

export interface CodeFix {
  description: string;
  files: string[];
  changes: string;
}

class CodingAgent extends BaseAgent {
  constructor() {
    super(
      'coding',
      'An agent that can write and understand code, perform automated bug fixes, and create pull requests.'
    );
  }

  protected async executeInternal(task: string): Promise<string> {
    this.log(`CodingAgent received task: ${task}`);
    // In the future, this could be a call to a code generation model
    return `I have received the coding task: '${task}'. I will work on it.`;
  }

  /**
   * Full automated fix lifecycle:
   * 1. Identify documented issues
   * 2. Generate code fix
   * 3. Execute fix in sandbox for testing
   * 4. Create PR upon successful verification
   */
  async performAutomatedFixLifecycle(params: {
    repositoryPath: string;
    issueSource?: 'error_log' | 'code_analysis' | 'manual';
  }): Promise<{
    success: boolean;
    sandboxId?: string;
    prUrl?: string;
    message: string;
  }> {
    try {
      console.log('Starting automated fix lifecycle...');

      // Step 1: Identify issues from code analysis
      const issues = await this.identifyIssues(params.repositoryPath);
      if (issues.length === 0) {
        return {
          success: false,
          message: 'No issues identified for automated fixing',
        };
      }

      console.log(`Identified ${issues.length} issues for fixing`);

      // Select high-priority issue
      const issueToFix = issues.find((i) => i.severity === 'high') || issues[0];

      // Step 2: Generate a code fix
      const fix = await this.generateCodeFix(issueToFix);

      // Step 3: Execute fix in sandbox environment
      const sandbox = await createSandbox({
        name: `fix-${issueToFix.issueType}-${Date.now()}`,
        description: `Automated fix for: ${issueToFix.description}`,
        createdBy: 'milla',
      });

      console.log(`Created sandbox: ${sandbox.id}`);

      // Add feature to sandbox
      const feature = await addFeatureToSandbox(sandbox.id, {
        name: `Fix: ${issueToFix.description}`,
        description: fix.description,
        files: fix.files,
      });

      if (!feature) {
        return {
          success: false,
          message: 'Failed to add feature to sandbox',
        };
      }

      // Step 4: Run tests in sandbox
      const testResults = await Promise.all([
        testFeature(sandbox.id, feature.id, 'unit'),
        testFeature(sandbox.id, feature.id, 'integration'),
      ]);

      const allTestsPassed = testResults.every((result) => result.passed);

      if (!allTestsPassed) {
        return {
          success: false,
          sandboxId: sandbox.id,
          message: `Tests failed in sandbox. Feature status: ${feature.status}`,
        };
      }

      // Evaluate sandbox readiness
      const readiness = evaluateSandboxReadiness(sandbox.id);
      if (!readiness.ready) {
        return {
          success: false,
          sandboxId: sandbox.id,
          message: `Sandbox not ready for merge: ${readiness.reasons.join(', ')}`,
        };
      }

      // Mark sandbox for merge
      await markSandboxForMerge(sandbox.id);

      // Step 5: Create PR via automated PR service
      const prRequest = await createPRForSandbox({
        sandboxId: sandbox.id,
        title: `Automated fix: ${issueToFix.description}`,
        description: `## Automated Code Fix\n\n**Issue Type:** ${issueToFix.issueType}\n**Severity:** ${issueToFix.severity}\n\n${fix.description}\n\n**Affected Files:**\n${fix.files.map((f) => `- ${f}`).join('\n')}\n\n**Test Results:**\n‚úÖ All tests passed\n\nThis PR was automatically generated by the CodingAgent.`,
        branch: sandbox.branchName,
        files: fix.files,
      });

      console.log(`Created PR request: ${prRequest.id}`);

      return {
        success: true,
        sandboxId: sandbox.id,
        prUrl: prRequest.prUrl,
        message: `Successfully created automated fix and PR for: ${issueToFix.description}`,
      };
    } catch (error) {
      console.error('Error in automated fix lifecycle:', error);
      return {
        success: false,
        message: `Error: ${error instanceof Error ? error.message : 'Unknown error'}`,
      };
    }
  }

  /**
   * Identify issues from error logs or code analysis
   */
  private async identifyIssues(
    repositoryPath: string
  ): Promise<IssueIdentification[]> {
    const issues: IssueIdentification[] = [];

    try {
      // For now, we'll use code analysis service to identify issues
      // In the future, this could also parse error logs
      const analysis = await analyzeCodeForIssues({
        repositoryPath,
        focusAreas: ['security', 'performance', 'quality'],
      });

      // Convert security issues
      analysis.securityIssues.forEach((issue: SecurityIssue) => {
        issues.push({
          issueType: 'security',
          description: issue.description,
          affectedFiles: issue.file ? [issue.file] : [],
          severity: issue.severity === 'critical' ? 'critical' : issue.severity,
        });
      });

      // Convert performance issues
      analysis.performanceIssues.forEach((issue: PerformanceIssue) => {
        issues.push({
          issueType: 'performance',
          description: issue.description,
          affectedFiles: issue.file ? [issue.file] : [],
          severity: issue.severity,
        });
      });

      // Convert code quality issues
      analysis.codeQualityIssues.forEach((issue: CodeQualityIssue) => {
        issues.push({
          issueType: 'enhancement',
          description: issue.description,
          affectedFiles: issue.file ? [issue.file] : [],
          severity: 'medium',
        });
      });
    } catch (error) {
      console.error('Error identifying issues:', error);
    }

    return issues;
  }

  /**
   * Generate a code fix for an identified issue using AI
   */
  private async generateCodeFix(issue: IssueIdentification): Promise<CodeFix> {
    try {
      // Use AI to generate a code fix based on the issue
      const prompt = `As an expert software engineer, analyze and fix the following ${issue.severity} severity ${issue.issueType} issue:

**Description:** ${issue.description}
**Affected Files:** ${issue.affectedFiles.join(', ')}

Please provide:
1. A clear description of the fix
2. The specific code changes needed
3. Why this fix resolves the issue

Format your response as JSON with keys: description, changes, reasoning`;

      // Use Minimax service for coding tasks
      const { generateMinimaxResponse } = await import(
        '../minimaxService'
      );

      const result = await generateMinimaxResponse(
        prompt,
        {
          conversationHistory: [],
          userName: 'CodingAgent',
        },
        4096 // Higher token limit for code generation
      );

      if (!result.success) {
        throw new Error(result.error || 'Failed to generate fix');
      }

      let aiResponse;
      try {
        aiResponse = JSON.parse(result.content);
      } catch {
        // Fallback if AI doesn't return valid JSON
        aiResponse = {
          description: result.content.slice(0, 200),
          changes: result.content,
          reasoning: 'AI-generated fix',
        };
      }

      return {
        description:
          aiResponse.description ||
          `Fix for ${issue.issueType}: ${issue.description}`,
        files: issue.affectedFiles,
        changes:
          aiResponse.changes ||
          `Automated fix applied to address ${issue.severity} severity ${issue.issueType} issue`,
      };
    } catch (error) {
      console.error('Error generating AI fix, using fallback:', error);
      // Fallback to simple fix description
      return {
        description: `Fix for ${issue.issueType}: ${issue.description}`,
        files: issue.affectedFiles,
        changes: `Automated fix applied to address ${issue.severity} severity ${issue.issueType} issue. Severity: ${issue.severity}. Requires manual review.`,
      };
    }
  }

  /**
   * Handle agent tasks (implements AgentDefinition interface)
   */
  async handleTask(task: AgentTask): Promise<any> {
    console.log(`CodingAgent handling task: ${task.action}`);

    switch (task.action) {
      case 'automated_fix':
        return await this.performAutomatedFixLifecycle({
          repositoryPath: task.payload?.repositoryPath || process.cwd(),
          issueSource: task.payload?.issueSource || 'code_analysis',
        });

      case 'analyze_code':
        return await this.identifyIssues(
          task.payload?.repositoryPath || process.cwd()
        );

      case 'generate_fix':
        return await this.generateCodeFix(task.payload?.issue);

      default:
        return {
          success: false,
          message: `Unknown action: ${task.action}`,
        };
    }
  }
}

export const codingAgent = new CodingAgent();

// ============================================================================
// P2.5: SCPA Self-Correction Logic Stub
// ============================================================================

/**
 * P2.5: Generate fix for agent failure (STUB)
 * This would analyze the error and generate code to fix it
 *
 * @param failureContext - Context about the agent failure
 * @returns Mock code patch object
 */
export async function generateFix(failureContext: any): Promise<{
  success: boolean;
  patch?: {
    files: string[];
    changes: string;
    description: string;
    testPlan: string;
  };
  error?: string;
}> {
  console.log(`üîß [SCPA] Generating fix for ${failureContext.agentName}`);
  console.log(`üîß [SCPA] Error: ${failureContext.error}`);

  // STUB: In production, this would:
  // 1. Analyze the error stack trace
  // 2. Locate the failing code
  // 3. Use LLM to understand the bug
  // 4. Generate a code fix
  // 5. Create test cases to verify the fix

  // Mock fix generation based on error pattern
  const errorStr = String(failureContext.error);
  let mockFix: any;

  if (errorStr.includes('undefined') || errorStr.includes('null')) {
    mockFix = {
      files: [`server/agents/${failureContext.agentName}.ts`],
      changes: `
// Add null check before accessing property
if (!variable) {
  console.warn('Variable is null/undefined, using default');
  variable = defaultValue;
}
`,
      description: 'Added null/undefined safety check',
      testPlan: 'Test with null input, verify no crash and proper fallback',
    };
  } else if (errorStr.includes('timeout') || errorStr.includes('ETIMEDOUT')) {
    mockFix = {
      files: [`server/agents/${failureContext.agentName}.ts`],
      changes: `
// Increase timeout and add retry logic
const result = await retry(
  () => apiCall(),
  { retries: 3, timeout: 60000 }
);
`,
      description: 'Added retry logic and increased timeout',
      testPlan: 'Test with slow network, verify retries work',
    };
  } else if (errorStr.includes('parse') || errorStr.includes('JSON')) {
    mockFix = {
      files: [`server/agents/${failureContext.agentName}.ts`],
      changes: `
// Add JSON parsing error handling
try {
  const data = JSON.parse(response);
} catch (parseError) {
  console.error('JSON parse failed:', parseError);
  return fallbackValue;
}
`,
      description: 'Added JSON parsing error handling',
      testPlan: 'Test with invalid JSON, verify graceful fallback',
    };
  } else {
    // Generic error handling fix
    mockFix = {
      files: [`server/agents/${failureContext.agentName}.ts`],
      changes: `
// Add generic error handling
try {
  // Original code here
} catch (error) {
  console.error('Operation failed:', error);
  // Log to monitoring service
  await reportError(error);
  // Return safe fallback
  return defaultResponse;
}
`,
      description: 'Added comprehensive error handling',
      testPlan: 'Test error scenarios, verify proper logging and fallback',
    };
  }

  console.log(`‚úÖ [SCPA] Mock fix generated for ${failureContext.agentName}`);
  console.log(`üìù [SCPA] Fix description: ${mockFix.description}`);

  // TODO: In production:
  // 1. Actually modify the file with the fix
  // 2. Run tests in sandbox environment
  // 3. If tests pass, create PR
  // 4. If tests fail, iterate on the fix
  // const sandbox = await createSandbox(`scpa-fix-${Date.now()}`);
  // await applyPatch(sandbox, mockFix);
  // const testResults = await runTests(sandbox);
  // if (testResults.passed) {
  //   await createPRForSandbox(sandbox);
  // }

  return {
    success: true,
    patch: mockFix,
  };
}

/**
 * P2.5: Apply generated fix to codebase (STUB)
 * In production, this would actually modify files
 */
export async function applyFixToCodebase(patch: any): Promise<boolean> {
  console.log(`üîß [SCPA] Applying fix to codebase (STUB)`);
  console.log(`üìÅ [SCPA] Files to modify: ${patch.files.join(', ')}`);

  // STUB: Would actually modify files here
  // TODO: Use fs to read/write files with the patch
  // for (const file of patch.files) {
  //   const content = await fs.readFile(file, 'utf-8');
  //   const updated = applyPatch(content, patch.changes);
  //   await fs.writeFile(file, updated);
  // }

  console.log(`‚úÖ [SCPA] Fix applied successfully (STUB)`);
  return true;
}

// Register the coding agent with the registry for task-based operations
import { registerAgent } from './registry';

registerAgent({
  name: 'CodingAgent',
  description: 'Automated code analysis, bug fixing, and PR creation agent',
  handleTask: async (task: AgentTask) => {
    return await codingAgent.handleTask(task);
  },
});
