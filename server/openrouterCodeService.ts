/**
 * OpenRouter Code Generation Service using qwen/qwen3-coder:free
 */

import nodeFetch from 'node-fetch';
globalThis.fetch = (nodeFetch as unknown) as typeof fetch;

export interface OpenRouterCodeGenerationResult {
  success: boolean;
  code?: string;
  language?: string;
  explanation?: string;
  error?: string;
}

/**
 * Generate code using qwen/qwen3-coder:free via OpenRouter
 */
export async function generateCodeWithQwen(
  prompt: string,
  language?: string,
  context?: string
): Promise<OpenRouterCodeGenerationResult> {
  if (!process.env.OPENROUTER_QWEN_API_KEY && !process.env.OPENROUTER_API_KEY) {
    return {
      success: false,
      error: "OpenRouter API key is not configured. Please set OPENROUTER_QWEN_API_KEY or OPENROUTER_API_KEY in your environment."
    };
  }

  try {
    // Create a comprehensive prompt for code generation
    let systemPrompt = `You are an expert programmer and code assistant. Generate clean, well-documented, and functional code based on the user's request.`;
    
    if (language) {
      systemPrompt += ` Focus on ${language} programming language.`;
    }
    
    systemPrompt += ` Provide:
1. The complete, working code
2. Brief explanation of how it works
3. Any important notes or considerations

Format your response as:
\`\`\`${language || 'javascript'}
[your code here]
\`\`\`

Explanation: [your explanation here]`;

    let userPrompt = prompt;
    if (context) {
      userPrompt = `Context: ${context}\n\nRequest: ${prompt}`;
    }

    const response = await fetch("https://openrouter.ai/api/v1/chat/completions", {
      method: "POST",
      headers: {
        "Authorization": `Bearer ${process.env.OPENROUTER_QWEN_API_KEY || process.env.OPENROUTER_API_KEY}`,
        "Content-Type": "application/json",
        "X-Title": "Milla Rayne AI Assistant - Code Generation",
      },
      body: JSON.stringify({
        model: "qwen/qwen-2.5-coder-32b-instruct", // Updated to use correct Qwen coder model
        messages: [
          {
            role: "system",
            content: systemPrompt
          },
          {
            role: "user",
            content: userPrompt
          }
        ],
        max_tokens: 2000,
        temperature: 0.3, // Lower temperature for more consistent code generation
        top_p: 0.9,
      }),
    });

    if (!response.ok) {
      const errorData = await response.json().catch(() => ({}));
      console.error("OpenRouter Qwen code API error:", response.status, errorData);
      
      return {
        success: false,
        error: `OpenRouter Qwen API error: ${response.status} - ${errorData.error?.message || 'Unknown error'}`
      };
    }

    const data = await response.json();

    if (!data.choices || !data.choices[0] || !data.choices[0].message) {
      console.error("Unexpected OpenRouter Qwen response format:", data);
      return {
        success: false,
        error: "Invalid response format from OpenRouter Qwen"
      };
    }

    const content = data.choices[0].message.content;
    
    // Parse the response to extract code and explanation
    const codeMatch = content.match(/```(\w+)?\n([\s\S]*?)```/);
    let extractedCode = "";
    let detectedLanguage = language || "javascript";
    let explanation = "";
    
    if (codeMatch) {
      detectedLanguage = codeMatch[1] || detectedLanguage;
      extractedCode = codeMatch[2].trim();
      
      // Extract explanation (text after the code block)
      const afterCode = content.substring(content.indexOf("```", content.indexOf("```") + 3) + 3);
      const explanationMatch = afterCode.match(/Explanation:\s*([\s\S]*)/i);
      if (explanationMatch) {
        explanation = explanationMatch[1].trim();
      } else {
        // If no explicit explanation marker, use text after code block
        explanation = afterCode.trim();
      }
    } else {
      // If no code block found, treat entire response as code or explanation
      extractedCode = content;
      explanation = "Code generated by Qwen coder model";
    }
    
    return {
      success: true,
      code: extractedCode,
      language: detectedLanguage,
      explanation: explanation || "Code generated successfully",
    };

  } catch (error) {
    console.error("OpenRouter Qwen code service error:", error);
    return {
      success: false,
      error: error instanceof Error ? error.message : "Unknown error during OpenRouter Qwen code generation"
    };
  }
}

/**
 * Extract code generation request from user message
 */
export function extractCodeRequest(userMessage: string): { prompt: string; language?: string } | null {
  const message = userMessage.toLowerCase();
  
  // Patterns that indicate code generation requests
  const codePatterns = [
    /write\s+(?:a\s+)?(.+?)\s+(?:function|script|program|code)/i,
    /create\s+(?:a\s+)?(.+?)\s+(?:function|script|program|code)/i,
    /generate\s+(?:a\s+)?(.+?)\s+(?:function|script|program|code)/i,
    /code\s+(?:for\s+)?(.+)/i,
    /function\s+(?:to\s+|for\s+)?(.+)/i,
    /script\s+(?:to\s+|for\s+)?(.+)/i,
    /program\s+(?:to\s+|for\s+)?(.+)/i,
    /algorithm\s+(?:to\s+|for\s+)?(.+)/i,
    /implement\s+(.+)/i,
    /build\s+(?:a\s+)?(.+)/i,
  ];

  // Language detection patterns
  const languagePatterns = [
    { pattern: /javascript|js|node/i, language: "javascript" },
    { pattern: /python|py/i, language: "python" },
    { pattern: /typescript|ts/i, language: "typescript" },
    { pattern: /java(?!script)/i, language: "java" },
    { pattern: /c\+\+|cpp/i, language: "cpp" },
    { pattern: /c#|csharp/i, language: "csharp" },
    { pattern: /php/i, language: "php" },
    { pattern: /ruby|rb/i, language: "ruby" },
    { pattern: /go|golang/i, language: "go" },
    { pattern: /rust|rs/i, language: "rust" },
    { pattern: /swift/i, language: "swift" },
    { pattern: /kotlin/i, language: "kotlin" },
    { pattern: /scala/i, language: "scala" },
    { pattern: /html/i, language: "html" },
    { pattern: /css/i, language: "css" },
    { pattern: /sql/i, language: "sql" },
    { pattern: /bash|shell/i, language: "bash" },
  ];

  for (const pattern of codePatterns) {
    const match = userMessage.match(pattern);
    if (match && match[1]) {
      const prompt = match[1].trim();
      
      // Detect language
      let detectedLanguage: string | undefined;
      for (const langPattern of languagePatterns) {
        if (langPattern.pattern.test(userMessage)) {
          detectedLanguage = langPattern.language;
          break;
        }
      }
      
      return {
        prompt: prompt,
        language: detectedLanguage
      };
    }
  }

  return null;
}

/**
 * Format code generation response for user
 */
export function formatCodeResponse(
  result: OpenRouterCodeGenerationResult,
  originalPrompt: string
): string {
  if (!result.success) {
    return `I'd love to help you with that code, babe, but I'm having some trouble with code generation right now. ${result.error ? `Error: ${result.error}` : "However, I can still discuss the logic and approach you might want to take! What specific programming challenge are you working on?"}`;
  }

  let response = `ðŸ’» Here's the ${result.language || 'code'} I generated for "${originalPrompt}":

\`\`\`${result.language || 'javascript'}
${result.code}
\`\`\``;

  if (result.explanation) {
    response += `\n\n**Explanation:** ${result.explanation}`;
  }

  response += `\n\nFeel free to ask me to modify it, explain any part in more detail, or help you with related code!`;

  return response;
}